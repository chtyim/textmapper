{{ template "header" . -}}

import { NodeType, NodeFlags, Listener } from '../listener'
import { Parser, SyntaxError, ErrorMsg{{if .Parser.IsRecovering }}, ErrorHandler{{end}} } from '../parser'
import { Selector } from '../selector';
{{ if $.Options.TokenStream -}}
import { TokenStream } from '../stream';
{{ else -}}
import { Lexer } from '../lexer';
{{ end -}}
import { Tree, Node } from './tree'
{{range $index, $inp := .Parser.Inputs -}}
{{- if $inp.Synthetic }}{{continue}}{{end}}
/**
* Parses the given content string {{if $.Parser.HasMultipleUserInputs}}as a {{$.NontermID $inp.Nonterm}}{{end}} into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTree{{if $.Parser.HasMultipleUserInputs}}From{{$.NontermID $inp.Nonterm}}{{end}}(content: string{{if $.Parser.IsRecovering }}, eh: ErrorHandler{{end}}): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: {{if $.Options.TokenStream}}TokenStream{{else}}Lexer{{end}}) : { err? : SyntaxError } => {
    return p.parse{{if $.Parser.HasMultipleUserInputs}}{{$.NontermID $inp.Nonterm}}{{end}}({{ if $.Options.TokenStream }}s{{else}}l{{end}});
  };
  return createTree(content, parseFunc{{if $.Parser.IsRecovering }}, eh{{end}});
}
{{end -}}

function createTree(content: string, parseFunc: (p: Parser, s: {{if $.Options.TokenStream}}TokenStream{{else}}Lexer{{end}}) => { err? : SyntaxError }{{if .Parser.IsRecovering }}, eh: ErrorHandler{{end}}): { tree?: Tree, err?: Error } {
  const builder = new TreeBuilder(content);
  const eventListener: Listener = (t: NodeType, flags: NodeFlags, offset: number, endOffset: number) => {
    builder.addNode(t, flags, offset, endOffset);
  };
{{ if $.Options.TokenStream -}}
  const ts = new TokenStream(content, eventListener);
{{ else -}}
  const l = new Lexer(content);
{{ end -}}
  const p = new Parser({{if .Parser.IsRecovering }}eh, {{end}}eventListener);

  let res = parseFunc(p, {{ if $.Options.TokenStream }}ts{{else}}l{{end}});
  if (res.err) {
    return { err: new Error(ErrorMsg(res.err)) };
  }

  return builder.build();
}

class TreeBuilder {

  readonly _tree: DefaultTree;
  _stack: DefaultNode[];

  constructor(content: string) {
    this._tree = new DefaultTree(content);
    this._stack = [];
  }

  addNode(t: NodeType, flags: NodeFlags, offset: number, endOffset: number) {
    let start = this._stack.length;
    let end = start;

    while (start > 0 && this._stack[start - 1].offset() >= offset) {
      start--;
      if (this._stack[start].offset() >= endOffset) {
        end--;
      }
    }

    let node: DefaultNode = new DefaultNode(this._tree, t, offset, endOffset);
    if (start < end) {
      node._firstChild = this._stack[start];
      let prev: DefaultNode | null = null;
      for (let i = end - 1; i >= start; i--) {
        let n = this._stack[i];
        n._parent = node;
        n._next = prev;
        prev = n;
      }
    }
    if (end === this._stack.length) {
      this._stack = this._stack.slice(0, start);
      this._stack.push(node);
    } else if (start < end) {
      this._stack[start] = node;
      let copyLen = this._stack.length - end;
      this._stack.copyWithin(start + 1, end);
      this._stack = this._stack.slice(0, start + 1 + copyLen);
    } else {
      // push a node to the end to enlarge the array, which get replaced by the copyWithin call.
      this._stack.push(node);
      this._stack.copyWithin(start + 1, start);
      this._stack[start] = node;
    }
  }

  build(): { tree?: Tree, err?: Error } {
{{- if .Options.FileNode }}
    this.addNode(NodeType.{{.Options.FileNode}}, 0, 0, this._tree._content.length);
{{- else }}
    if (this._stack.length !== 1) {
      return { err : new Error("exactly one root node is expected") };
    }
{{- end}}
    this._tree._root = this._stack[0];
    return { tree: this._tree };
  }
}

class DefaultTree implements Tree {

  readonly _content: string;
  readonly _lines: number[];
  _root: Node;

  constructor(content: string) {
    this._content = content;
    this._lines = this.lineOffsets(content);
  }

  text(): string {
    return this._content;
  }

  root(): Node {
    return this._root;
  }

  // returns the start position of the node as 1-based line and column.
  lineColumn(offset: number): { line: number; column: number } {
    const lines = this._lines;

    // Use a binary search to find the line number.
    let left = 0;
    let right = lines.length - 1;
    let line = 0
    while (left <= right) {
      let mid = Math.floor((left + right) / 2)
      if (lines[mid] > offset) {
        right = mid - 1
      } else {
        line = mid
        left = mid + 1
      }
    }
    return { line: line + 1, column: offset - lines[line] + 1 };
  }

  private lineOffsets(str: string): number[] {
    const lines: number[] = [0]; // Initialize with the starting offset (0)
    let offset = 0;

    let i = str.indexOf('\n', offset);
    while (i !== -1) {
      lines.push(offset);
      offset = i + 1;
      i = str.indexOf('\n', offset);
    }

    return lines;
  }
}

class DefaultNode implements Node {
  _tree: DefaultTree;
  _type: NodeType;
  _offset: number;
  _endOffset: number;
  _parent: DefaultNode | null;
  _next: DefaultNode | null;
  _firstChild: DefaultNode | null;

  constructor(tree: DefaultTree, type: NodeType, offset: number, endOffset: number) {
    this._tree = tree;
    this._type = type;
    this._offset = offset;
    this._endOffset = endOffset;
    this._parent = null;
    this._next = null;
    this._firstChild = null;
  }

  type(): NodeType {
    return this._type;
  }

  offset(): number {
    return this._offset;
  }

  endOffset(): number {
    return this._endOffset;
  }

  tree(): Tree {
    return this._tree;
  }

  text(): string {
    return this._tree.text().substring(this._offset, this._endOffset);
  }

  lineColumn(): { line: number; column: number } {
    return this._tree.lineColumn(this._offset);
  }

  next(selector: Selector): Node | null {
    let n = this._next;
    while (n != null && !selector(n._type)) {
      n = n._next;
    }
    return n;
  }

  nextAll(selector: Selector): Iterable<Node> {
    const iteratorFunc = createIterator.bind(null, this._next, selector);
    return {
      [Symbol.iterator](): Iterator<Node> {
        return iteratorFunc();
      }
    };
  }

  child(selector: Selector): Node | null {
    let c = this._firstChild;
    while (c != null && !selector(c._type)) {
      c = c._next;
    }
    return c;
  }

  children(selector: Selector): Iterable<Node> {
    const iteratorFunc = createIterator.bind(null, this._firstChild, selector);
    return {
      [Symbol.iterator](): Iterator<Node> {
        return iteratorFunc();
      }
    };
  }

  descendants(selector: Selector): Iterable<Node> {
    let stack = [this.children(selector)[Symbol.iterator]()];
    return {
      [Symbol.iterator](): Iterator<Node> {
        return {
          next(): IteratorResult<Node> {
            while (stack.length > 0) {
              let next = stack[stack.length - 1].next();
              if (!next.done) {
                stack.push(next.value.children(selector)[Symbol.iterator]());
                return next;
              }
              stack.pop();
            }
            return { value: undefined, done: true };
          }
        };
      }
    };
  }
}

function createIterator(node: DefaultNode | null, selector: Selector): Iterator<Node> {
  let n: DefaultNode | null = node;
  return {
    next(): IteratorResult<Node> {
      while (n && !selector(n._type)) {
        n = n._next;
      }
      if (!n) {
        return { value: undefined, done: true };
      }
      const res = n;
      n = n._next;
      return { value: res, done: false };
    }
  };
}